// distribuciones.ts

/**
 * Generates a random number from a uniform distribution.
 * Formula: X = A + R * (B - A)
 * @param lowerLimit The lower limit of the distribution (A).
 * @param upperLimit The upper limit of the distribution (B).
 * @param randomNumber A random number R, expected to be in the interval [0, 1).
 * @returns A random number X from the uniform distribution [lowerLimit, upperLimit).
 */
export function uniforme(
  lowerLimit: number,
  upperLimit: number,
  randomNumber: number
): number {
  if (lowerLimit > upperLimit) {
    throw new Error(
      "Lower limit cannot be greater than upper limit for uniform distribution."
    )
  }
  if (randomNumber < 0 || randomNumber >= 1) {
    throw new Error("randomNumber must be in [0, 1). Received: " + randomNumber)
  }
  return lowerLimit + randomNumber * (upperLimit - lowerLimit)
}

/**
 * Generates a random number using the user-specified formula: param_media - ln(1 - R).
 * Note: If R is a random number from U[0,1), then -ln(1-R) follows an Exponential(1) distribution (mean 1, rate 1).
 * Thus, this function generates values from a distribution Y = param_media + Exp(1).
 * This distribution has a mean of (param_media + 1) and its values are >= param_media.
 * This is distinct from the standard method to generate a random number from an exponential distribution
 * with a mean M, which is typically -M * ln(1-R) or -M * ln(R).
 * @param param_media The parameter 'media' as specified in the user's formula.
 * @param randomNumber A random number R, expected to be in the interval [0, 1).
 * @returns A random number generated using the formula param_media - ln(1 - randomNumber).
 *          Result is >= param_media. If randomNumber is 0, result is param_media.
 *          If randomNumber approaches 1, result approaches Positive Infinity.
 */
export function exponencial(param_media: number, randomNumber: number): number {
  if (randomNumber < 0 || randomNumber >= 1) {
    throw new Error("randomNumber must be in [0, 1). Received: " + randomNumber)
  }

  // Formula: param_media - Math.log(1 - randomNumber)
  // If randomNumber = 0, (1-randomNumber)=1, Math.log(1)=0. Result: param_media.
  // If randomNumber -> 1-, (1-randomNumber) -> 0+, Math.log(1-randomNumber) -> -Infinity. Result -> +Infinity.
  return (-param_media) * Math.log(1 - randomNumber)
}

/**
 * Generates a random number from a normal distribution using the Box-Muller transform.
 * This function uses one of the two standard normal variates generated by the transform.
 * Standard normal variate: Z0 = sqrt(-2 * ln(R1)) * cos(2 * PI * R2)
 * Resulting variate: X = mean + stdDev * Z0
 * @param media The mean (mu) of the desired normal distribution.
 * @param desvStd The standard deviation (sigma) of the desired normal distribution. Must be non-negative.
 * @param randomNumber1 A random number R1, must be in the interval (0, 1] (exclusive of 0 for log, inclusive of 1).
 * @param randomNumber2 A random number R2, must be in the interval [0, 1).
 * @returns A random number from N(mean, stdDev^2).
 */
export function normal(
  media: number,
  desvStd: number,
  randomNumber1: number,
  randomNumber2: number
): number {
  if (desvStd < 0) {
    throw new Error("Standard deviation (stdDev) must be non-negative.")
  }
  if (randomNumber1 <= 0 || randomNumber1 > 1) {
    throw new Error(
      "randomNumber1 must be in (0, 1]. Received: " + randomNumber1
    )
  }
  if (randomNumber2 < 0 || randomNumber2 >= 1) {
    throw new Error(
      "randomNumber2 must be in [0, 1). Received: " + randomNumber2
    )
  }

  // Box-Muller transform:
  // randomNumber1 corresponds to U1, used in Math.log. Must be > 0.
  // If randomNumber1 is 1, Math.log(1) is 0, so z0 is 0. Result is 'mean'. This is acceptable.
  const z0 =
    Math.sqrt(-2.0 * Math.log(randomNumber1)) *
    Math.cos(2.0 * Math.PI * randomNumber2)

  return media + desvStd * z0
}

/**
 * Generates a random integer from a Poisson distribution using inverse transform sampling.
 * The probability mass function (PMF) is P(X=k) = (lambda^k * exp(-lambda)) / k!.
 * This function finds k such that Sum_{i=0 to k-1} P(X=i) <= R < Sum_{i=0 to k} P(X=i).
 * @param mean The mean (lambda) of the Poisson distribution. Must be non-negative.
 * @param randomNumber A random number R, expected to be in the interval [0, 1).
 * @returns A random integer k from Poisson(mean).
 */
export function poisson(mean: number, randomNumber: number): number {
  if (mean < 0) {
    throw new Error(
      "Mean (lambda) must be non-negative for Poisson distribution."
    )
  }
  if (randomNumber < 0 || randomNumber >= 1) {
    throw new Error("randomNumber must be in [0, 1). Received: " + randomNumber)
  }

  if (mean === 0) {
    // Poisson(0) always yields 0.
    return 0
  }

  let k = 0
  let p_k = Math.exp(-mean) // Probability P(X=0)
  let cdf = p_k // Cumulative distribution function starting with P(X=0)

  // Loop while the random number is greater than or equal to the current cumulative probability
  while (randomNumber >= cdf) {
    k++
    // Iterative formula for P(X=k) using P(X=k-1): P(k) = P(k-1) * lambda / k
    p_k = (p_k * mean) / k
    cdf += p_k

    // Safety break for scenarios where cdf might stall due to floating point precision,
    // especially if randomNumber is extremely close to 1.0 or for very large means.
    // A Poisson variate is highly unlikely to be extremely far from its mean.
    // This check helps prevent excessively long or infinite loops in such edge cases.
    // The threshold (e.g., k > mean + 15*sqrt(mean) AND k > some_large_number) is heuristic.
    if (cdf === 1.0 || (k > mean + 15 * Math.sqrt(mean) && k > 100000)) {
      break
    }
  }
  return k
}
